```dataviewjs
// ================
// è°ƒè¯•é€‰é¡¹ 
// ================
const DEBUG_MODE = false; // è®¾ç½®ä¸ºtrueå¯ç”¨è°ƒè¯•
const DEBUG_DATE = "2023-11-15"; // è°ƒè¯•ç”¨æ—¥æœŸ (YYYY-MM-DD)

// è·å–å½“å‰æ—¥æœŸï¼ˆå¯è¢«è°ƒè¯•æ¨¡å¼è¦†ç›–ï¼‰
function getCurrentDate() {
    if (DEBUG_MODE) {
        return new Date(DEBUG_DATE);
    }
    return new Date();
}

// ================
// é…ç½®é¡¹
// ================
const CATEGORY_TAGS = ["#A", "#B", "#C"] // ç‹¬ç«‹çš„ä¸‰çº§åˆ†ç±»æ ‡ç­¾
const KNOWLEDGE_PREFIX = "#é¢˜ç›®/çŸ¥è¯†ç‚¹/"
const DEFFICULTY_PREFIX = "#é¢˜ç›®/éš¾åº¦/"
// å®šä¹‰å„ç±»åˆ«çš„æ›´æ–°å‘¨æœŸ(å¤©)
const UPDATE_CYCLES = {
    "#A": 5,  // Aç±»é¢˜ç›®æ¯5å¤©æ›´æ–°ä¸€æ¬¡
    "#B": 3,  // Bç±»é¢˜ç›®æ¯3å¤©æ›´æ–°ä¸€æ¬¡
    "#C": 1,  // Cç±»é¢˜ç›®æ¯å¤©æ›´æ–°
    "hot100": 1 // Hot100æ¨èæ¯å¤©æ›´æ–°ä¸€æ¬¡
}

// ================
// æ•°æ®å¤„ç†æ¶æ„
// ================
const classifyByTag = (tag) => (p) => p.file.tags.includes(tag)

// ================
// ç»Ÿä¸€çš„éšæœºæ•°ç”Ÿæˆå™¨ï¼ˆå¸¦çŠ¶æ€ï¼‰
// ================
function createSeededRandom(seed) {
    // çº¿æ€§åŒä½™ç”Ÿæˆå™¨ (LCG) å‚æ•°
    const a = 1664525;
    const c = 1013904223;
    const m = Math.pow(2, 32);
    let state = seed;
    state = (a * state + c) % m;

    return function() {
        state = (a * state + c) % m;
        return state / m; // è¿”å› 0~1 ä¹‹é—´çš„æµ®ç‚¹æ•°
    };
}

// è·å–å½“å‰æ—¥æœŸå’Œæ—¶é—´ä¿¡æ¯
dv.paragraph(`***${getCurrentDate().toISOString().slice(0, 10)}***`)

// ================
// é€šç”¨å‘¨æœŸéšæœºç”Ÿæˆå™¨å·¥å‚ï¼ˆä¿®å¤ç‰ˆï¼‰
// ================
function createPeriodicRandomGenerator(periodDays) {
    return function() {
        const currentDate = getCurrentDate();
        
        // è®¡ç®—æ—¥æœŸçš„å¤©æ•°ï¼ˆä»æŸä¸ªå›ºå®šæ—¥æœŸå¼€å§‹ï¼‰
        const daysSince1970 = Math.floor(currentDate.getTime() / (24 * 60 * 60 * 1000));
        const cycleNumber = Math.floor(daysSince1970 / periodDays);
        
        // è®¡ç®—å½“å‰å‘¨æœŸçš„èµ·å§‹æ—¥æœŸ
        const cycleDaysSince1970 = cycleNumber * periodDays;
        const cycleStartDate = new Date(cycleDaysSince1970 * 24 * 60 * 60 * 1000);
        
        // è®¡ç®—å½“å‰å‘¨æœŸçš„ç»“æŸæ—¥æœŸ
        const nextCycleStartMs = (cycleNumber + 1) * periodDays * 24 * 60 * 60 * 1000;
        const cycleEndDate = new Date(nextCycleStartMs);
        
        if (DEBUG_MODE) {
            console.log(`å‘¨æœŸ=${periodDays}å¤©, å½“å‰æ—¥æœŸ=${currentDate.toISOString().slice(0,10)}, å¤©æ•°=${daysSince1970}, å‘¨æœŸç¼–å·=${cycleNumber}`);
            console.log(`å‘¨æœŸèµ·å§‹=${cycleStartDate.toISOString().slice(0,10)}, å‘¨æœŸç»“æŸ=${cycleEndDate.toISOString().slice(0,10)}`);
        }
        
        return {
            random: createSeededRandom(cycleNumber),
            cycleNumber: cycleNumber,
            startDate: cycleStartDate,
            expiryDate: cycleEndDate,
            isExpired: currentDate >= cycleEndDate
        };
    }
}

// æ—¥æœŸæ ¼å¼åŒ–å‡½æ•°
function formatDate(date) {
    const options = { year: 'numeric', month: '2-digit', day: '2-digit' };
    return date.toLocaleDateString('zh-CN', options);
}

// ================
// åˆ›å»ºå„ç§å‘¨æœŸçš„éšæœºç”Ÿæˆå™¨
// ================
const categoryGenerators = {};
const categoryExpiryDates = {};
const categoryStartDates = {};
const categoryIsExpired = {};
for (const tag of CATEGORY_TAGS) {
    const cycle = UPDATE_CYCLES[tag];
    const { random, expiryDate, startDate, cycleNumber, isExpired } = createPeriodicRandomGenerator(cycle)();
    categoryGenerators[tag] = random;
    categoryExpiryDates[tag] = expiryDate;
    categoryStartDates[tag] = startDate;
    categoryIsExpired[tag] = isExpired;
    
    if (DEBUG_MODE) {
        console.log(`ç±»åˆ« ${tag} å‘¨æœŸç¼–å·: ${cycleNumber}, èµ·å§‹æ—¥æœŸ: ${startDate.toISOString().slice(0,10)}, æˆªæ­¢æ—¥æœŸ: ${expiryDate.toISOString().slice(0,10)}, æ˜¯å¦åˆ°æœŸ: ${isExpired}`);
    }
}

// åæ—¥å‘¨æœŸéšæœºç”Ÿæˆå™¨
const tenDayGenerator = createPeriodicRandomGenerator(10)();
const tenDayRandom = tenDayGenerator.random;
const tenDayStartDate = tenDayGenerator.startDate;
const tenDayExpiryDate = tenDayGenerator.expiryDate;
const tenDayIsExpired = tenDayGenerator.isExpired;

// Hot100å‘¨æœŸéšæœºç”Ÿæˆå™¨
const hot100Cycle = UPDATE_CYCLES["hot100"];
const hot100Generator = createPeriodicRandomGenerator(hot100Cycle)();
const hot100Random = hot100Generator.random;
const hot100StartDate = hot100Generator.startDate;
const hot100ExpiryDate = hot100Generator.expiryDate;
const hot100IsExpired = hot100Generator.isExpired;

if (DEBUG_MODE) {
    console.log(`åæ—¥ä¸“é¡¹å‘¨æœŸç¼–å·: ${tenDayGenerator.cycleNumber}, èµ·å§‹æ—¥æœŸ: ${tenDayStartDate.toISOString().slice(0,10)}, æˆªæ­¢æ—¥æœŸ: ${tenDayExpiryDate.toISOString().slice(0,10)}, æ˜¯å¦åˆ°æœŸ: ${tenDayIsExpired}`);
    console.log(`Hot100æ¨èå‘¨æœŸç¼–å·: ${hot100Generator.cycleNumber}, èµ·å§‹æ—¥æœŸ: ${hot100StartDate.toISOString().slice(0,10)}, æˆªæ­¢æ—¥æœŸ: ${hot100ExpiryDate.toISOString().slice(0,10)}, æ˜¯å¦åˆ°æœŸ: ${hot100IsExpired}`);
}

// è·å–æ‰€æœ‰æ¯”è¾ƒæ–‡ä»¶
const allComparisonFiles = dv.pages("#æ¯”è¾ƒ/");

// ================
// é€šç”¨çš„æ£€æŸ¥é¢˜ç›®åœ¨æŒ‡å®šå‘¨æœŸå†…æ˜¯å¦å·²å®Œæˆ
// ================
const isCompletedInPeriod = (problemNumber, requiredKnowledgeTag, startDate, endDate) => {
    // æŸ¥æ‰¾å¸¦æœ‰æ¯”è¾ƒæ ‡ç­¾çš„å¯¹åº”é¢˜å·æ–‡ä»¶
    const matchingFiles = allComparisonFiles.where(p => {
        // ä»æ–‡ä»¶åæå–é¢˜å·
        const fileNumberMatch = p.file.name.match(/^(\d+)\./);
        return fileNumberMatch && parseInt(fileNumberMatch[1]) === parseInt(problemNumber);
    });
    
    // è°ƒæ•´èµ·å§‹æ—¥æœŸæå‰ä¸€å¤©
    const adjustedStartDate = new Date(startDate);
    adjustedStartDate.setDate(adjustedStartDate.getDate() - 1);
    
    // æ£€æŸ¥ä»»ä½•åŒ¹é…çš„æ–‡ä»¶æ˜¯å¦åœ¨æŒ‡å®šå‘¨æœŸå†…ä¸”åŒ…å«ç›¸å…³çŸ¥è¯†ç‚¹æ ‡ç­¾
    return matchingFiles.some(p => {
        // è·å–æ–‡ä»¶ä¸­çš„æ—¥æœŸæ ‡ç­¾
        const dateTag = p.file.tags.find(t => t.match(/^#\d{4}\/\d{2}\/\d{2}$/));
        if (!dateTag) return false;
        
        // æ£€æŸ¥æ˜¯å¦åŒ…å«ç›¸åº”çŸ¥è¯†ç‚¹æ ‡ç­¾ï¼ˆå¦‚æœæä¾›äº†ï¼‰
        if (requiredKnowledgeTag && !p.file.tags.includes(requiredKnowledgeTag)) return false;
        
        // è§£ææ—¥æœŸæ ‡ç­¾
        const [year, month, day] = dateTag.substring(1).split('/').map(Number);
        const fileDate = new Date(year, month - 1, day);
        
        // ä½¿ç”¨è°ƒæ•´åçš„èµ·å§‹æ—¥æœŸæ£€æŸ¥
        return fileDate >= adjustedStartDate && fileDate <= endDate;
    });
};

// ================
// æ ¸å¿ƒé€»è¾‘å®ç°
// ================
const questionBank = dv.pages("#é¢˜ç›®/") 

// æ„å»ºæ™ºèƒ½æ•°æ®æº
const categorizedData = CATEGORY_TAGS.map(tag => ({
    icon: {
        "#A": "ğŸŸ¢", 
        "#B": "ğŸŸ¡", 
        "#C": "ğŸ”´"
    }[tag],
    name: `${tag[1]}`,
    cycle: UPDATE_CYCLES[tag],
    startDate: categoryStartDates[tag],
    expiryDate: categoryExpiryDates[tag],
    isExpired: categoryIsExpired[tag],
    items: questionBank.where(classifyByTag(tag))
}))

// è·å–å¹¶å­˜å‚¨éšæœºé€‰æ‹©çš„é—®é¢˜
// ä½¿ç”¨æ–‡ä»¶ç³»ç»ŸAPIä»ç¼“å­˜ä¸­è¯»å–æˆ–å‘ç¼“å­˜ä¸­å†™å…¥å½“å‰å‘¨æœŸé¢˜ç›®
function getOrCreatePeriodQuestion(tag, items, cycleNumber) {
    // æ„é€ ç¼“å­˜é”®å
    const cacheKey = `${tag.replace("#", "")}_cycle_${cycleNumber}`;
    
    try {
        // å°è¯•ä»ç¼“å­˜ä¸­è¯»å–
        let cachedQuestion = app.metadataCache.getCache(cacheKey);
        
        // å¦‚æœæ‰¾ä¸åˆ°ç¼“å­˜çš„é—®é¢˜æˆ–å·²è¿‡æœŸï¼Œé‡æ–°éšæœºé€‰æ‹©å¹¶ç¼“å­˜
        if (!cachedQuestion || categoryIsExpired[tag]) {
            const randomGenerator = categoryGenerators[tag];
            const index = Math.floor(randomGenerator() * items.length);
            cachedQuestion = items[index];
            
            // å°†æ–°é€‰æ‹©çš„é—®é¢˜å†™å…¥ç¼“å­˜
            app.metadataCache.setCache(cacheKey, cachedQuestion);
        }
        
        return cachedQuestion;
    } catch (error) {
        console.error(`æ— æ³•è®¿é—®æˆ–å†™å…¥ç¼“å­˜: ${error}`);
        // å‘ç”Ÿé”™è¯¯æ—¶å›é€€åˆ°ç›´æ¥éšæœºé€‰æ‹©
        const randomGenerator = categoryGenerators[tag];
        const index = Math.floor(randomGenerator() * items.length);
        return items[index];
    }
}

// ä»æ¯ä¸ªç±»åˆ«ä¸­éšæœºè·å–é¢˜ç›®ï¼ˆè€ƒè™‘å‘¨æœŸï¼‰
function pickRandomByCategory(items, tag) {
    if (items.length === 0) return null;
    
    // è·å–å½“å‰å‘¨æœŸç¼–å·
    const currentDate = getCurrentDate();
    const daysSince1970 = Math.floor(currentDate.getTime() / (24 * 60 * 60 * 1000));
    const cycle = UPDATE_CYCLES[tag];
    const cycleNumber = Math.floor(daysSince1970 / cycle);
    
    // ä½¿ç”¨ç¼“å­˜ç³»ç»Ÿè·å–æˆ–åˆ›å»ºé—®é¢˜
    return getOrCreatePeriodQuestion(tag, items, cycleNumber);
}

// é€šç”¨éšæœºé€‰æ‹©å‡½æ•°
function pickRandom(items, count, randomFn) {
    if (items.length === 0) return [];
    if (!count) count = 1;
    
    // ä¸ºæ¯ä¸ªå…ƒç´ åˆ†é…éšæœºå€¼
    const withRandomValues = items.map(item => ({
        item: item,
        rand: randomFn()
    }));
    
    // æ’åºå¹¶é€‰å–å‰countä¸ª
    const sorted = withRandomValues.sort(a => a.rand);
    return sorted.slice(0, count).map(x => x.item);
}

// åŠ¨æ€ç”ŸæˆçŸ¥è¯†ç‚¹æ± 
const knowledgePool = [...new Set(
    questionBank.flatMap(p => 
        p.file.tags
            .filter(t => t.startsWith(KNOWLEDGE_PREFIX))
            .map(t => t.split('/')[2])
    )
)]

// ================
// åæ—¥ä¸“é¡¹é¢˜ç›®æŒä¹…åŒ–å­˜å‚¨
// ================
function getOrCreateTenDaySpecialTopic(cycleNumber, knowledgePool) {
    const storageKey = `tenDaySpecial_${cycleNumber}`;
    
    try {
        // å°è¯•ä»æœ¬åœ°å­˜å‚¨è¯»å–
        const storedTopic = localStorage.getItem(storageKey);
        
        if (storedTopic && knowledgePool.includes(storedTopic)) {
            if (DEBUG_MODE) {
                console.log(`ä»å­˜å‚¨ä¸­è¯»å–ä¸“é¡¹ä¸»é¢˜: ${storedTopic}`);
            }
            return storedTopic;
        }
        
        // å¦‚æœæ²¡æœ‰å­˜å‚¨æˆ–å­˜å‚¨çš„ä¸»é¢˜ä¸åœ¨å½“å‰çŸ¥è¯†æ± ä¸­ï¼Œåˆ™éšæœºé€‰æ‹©å¹¶å­˜å‚¨
        const randomTopic = pickRandom(knowledgePool, 1, tenDayRandom)[0];
        localStorage.setItem(storageKey, randomTopic);
        
        if (DEBUG_MODE) {
            console.log(`æ–°é€‰æ‹©çš„ä¸“é¡¹ä¸»é¢˜: ${randomTopic} å¹¶å­˜å‚¨`);
        }
        return randomTopic;
    } catch (e) {
        console.error("è®¿é—®æœ¬åœ°å­˜å‚¨å¤±è´¥:", e);
        return pickRandom(knowledgePool, 1, tenDayRandom)[0];
    }
}

// é€‰æ‹©ä»Šæ—¥ä¸“é¡¹ä¸»é¢˜ - ä½¿ç”¨æŒä¹…åŒ–ç‰ˆæœ¬
const todayHotTopic = knowledgePool.length > 0 
    ? getOrCreateTenDaySpecialTopic(tenDayGenerator.cycleNumber, knowledgePool)
    : "æ‰€æœ‰é¢†åŸŸ";

if (DEBUG_MODE) {
    console.log(`é€‰ä¸­çš„ä¸“é¡¹ä¸»é¢˜: ${todayHotTopic}`);
}

// ================
// æå–å¸¦ #æ¯”è¾ƒ/ æ ‡ç­¾ä¸” #YYYY/MM/DD æ ‡ç­¾åœ¨æœ¬æœˆçš„æ–‡ä»¶
// ================
const currentYear = getCurrentDate().getFullYear();
const currentMonth = getCurrentDate().getMonth() + 1; // æœˆä»½ä» 0 å¼€å§‹ï¼Œéœ€è¦åŠ  1

const comparisonFiles = dv.pages("#æ¯”è¾ƒ/")
    .where(p => {
        const dateTag = p.file.tags.find(t => t.startsWith("#" + currentYear + "/"));
        if (!dateTag) return false;
        const [year, month] = dateTag.split('/').slice(0, 2);
        return parseInt(month) === currentMonth;
    });

// ================
// å±•ç¤ºç»“æœ
// ================
dv.header(1, "ğŸ“Š æœ¬æœˆè¿›åº¦");
dv.paragraph(`\`\`\`progressbar\nid: progress-0\nkind: manual\nname: "è¿›åº¦({value}/{max})"\nvalue: ${comparisonFiles.length}\nmax: 100\nwidth: 60%\nbutton: false\n\`\`\``);


// ================
// å¯è§†åŒ–æ¨¡å—
// ================
dv.header(1, `âŒ› é‡æ¸©`)
dv.table(
    ["åˆ†ç±»", "éšæœºæŠ½é¢˜", "éš¾åº¦", "æˆªæ­¢æ—¥æœŸ", "å®Œæˆ"],
    categorizedData.map(section => {
        const caseFile = pickRandomByCategory(section.items, `#${section.name}`);
        
        // æå–é¢˜å·å’Œæ£€æŸ¥å®Œæˆæƒ…å†µ
        let problemNumber = null;
        let isCompleted = false;
        
        if (caseFile) {
            const problemNumberMatch = caseFile.file.name.match(/^(\d+)\./);
            problemNumber = problemNumberMatch ? problemNumberMatch[1] : null;
            isCompleted = problemNumber && isCompletedInPeriod(
                problemNumber, 
                null, // ä¸éœ€è¦ç‰¹å®šçŸ¥è¯†ç‚¹æ ‡ç­¾
                section.startDate, 
                section.expiryDate
            );
        }
        
        return [
            `${section.icon} ${section.name} (${section.items.length})`,
            caseFile ? caseFile.file.link : "â é¢˜åº“ç©ºç¼º",
            caseFile ? caseFile.file.tags
                .filter(t => t.startsWith(DEFFICULTY_PREFIX))
                .map(t => t.split('/')[2]).join(', ') : "--",
            formatDate(section.expiryDate),
            isCompleted ? "âœ…" : "â¬œ"
            
        ]
    })
)

// ================
// Hot100 é¢˜ç›®æŒ‘é€‰
// ================
const hot100Questions = dv.pages("#hot100");
const randomHot100Questions = pickRandom(hot100Questions, 3, hot100Random);

// å±•ç¤ºç»“æœ
if (randomHot100Questions.length > 0) {
    dv.header(1, "ğŸ”¥ Hot 100 æ¨è");
    dv.paragraph(`æˆªæ­¢æ—¥æœŸ: ${formatDate(hot100ExpiryDate)}`);
    
    dv.table(
        ["é¢˜ç›®", "éš¾åº¦", "å®Œæˆ"],
        randomHot100Questions.map(p => {
            // æå–é¢˜å·
            const problemNumberMatch = p.file.name.match(/^(\d+)\./);
            const problemNumber = problemNumberMatch ? problemNumberMatch[1] : null;
            
            // æ£€æŸ¥æ˜¯å¦å®Œæˆ
            const isCompleted = problemNumber && isCompletedInPeriod(
                problemNumber, 
                null, // ä¸éœ€è¦ç‰¹å®šçŸ¥è¯†ç‚¹æ ‡ç­¾
                hot100StartDate, 
                hot100ExpiryDate
            );
            
            return [
                p.file.link,
                p.file.tags.find(t => t.startsWith(DEFFICULTY_PREFIX))?.split("/").pop() || "æœªæ ‡æ³¨",
                isCompleted ? "âœ…" : "â¬œ"
            ];
        })
    );
} else {
    dv.paragraph("ğŸ“­ ä»Šæ—¥æ²¡æœ‰ Hot 100 é¢˜ç›®æ¨èã€‚");
}

// ================
// åæ—¥ä¸“é¡¹é¢˜ç›®å±•ç¤ºï¼ˆæ·»åŠ å®Œæˆåˆ—ï¼‰
// ================
dv.header(1, `ğŸŒŸ åæ—¥ä¸“é¡¹ï¼š${todayHotTopic}`)
dv.paragraph(`æˆªæ­¢æ—¥æœŸï¼š${formatDate(tenDayExpiryDate)}`)

const currentKnowledgeTag = KNOWLEDGE_PREFIX + todayHotTopic;
const difficultyOrder = { "ç®€å•": 1, "ä¸­ç­‰": 2, "å›°éš¾": 3, "æœªçŸ¥": 4 };

const specialQuestions = questionBank
    .where(p => p.file.tags.includes(currentKnowledgeTag))
    .sort(p => {
        const diffTag = p.file.tags.find(t => t.startsWith(DEFFICULTY_PREFIX));
        const difficulty = diffTag ? diffTag.split("/").pop() : "æœªçŸ¥";
        return difficultyOrder[difficulty] || 4;
    }, "asc");

if (specialQuestions.length > 0) {
    dv.table(
        ["é¢˜ç›®é“¾æ¥", "éš¾åº¦", "å®Œæˆ"],
        specialQuestions.map(p => {
            // ä»æ–‡ä»¶åæå–é¢˜å·
            const problemNumberMatch = p.file.name.match(/^(\d+)\./);
            const problemNumber = problemNumberMatch ? problemNumberMatch[1] : null;
            
            // æ£€æŸ¥æ˜¯å¦å®Œæˆ - ä½¿ç”¨ä¸“é—¨çš„è§„åˆ™ï¼Œè¦æ±‚æ¯”è¾ƒæ–‡ä»¶å¿…é¡»åŒ…å«çŸ¥è¯†ç‚¹æ ‡ç­¾
            const isCompleted = problemNumber && isCompletedInPeriod(
                problemNumber, 
                currentKnowledgeTag, // å¿…é¡»åŒ…å«å½“å‰ä¸“é¡¹çš„çŸ¥è¯†ç‚¹æ ‡ç­¾
                tenDayStartDate, 
                tenDayExpiryDate
            );
            
            return [
                p.file.link,
                p.file.tags.find(t => t.startsWith(DEFFICULTY_PREFIX))?.split("/").pop() || "æœªæ ‡æ³¨",
                isCompleted ? "âœ…" : "â¬œ"
            ];
        })
    );
}

// ================
// æœªå®Œæˆé¢˜ç›®å±•ç¤ºï¼ˆæ— ABCæ ‡ç­¾çš„é¢˜ç›®ï¼‰
// ================
const unfinishedQuestions = questionBank
    .where(p => !p.file.tags.some(t => CATEGORY_TAGS.includes(t))) // è¿‡æ»¤æ— ABCæ ‡ç­¾çš„é¢˜ç›®
    .sort(p => {
        const diffTag = p.file.tags.find(t => t.startsWith(DEFFICULTY_PREFIX));
        const difficulty = diffTag ? diffTag.split("/").pop() : "æœªçŸ¥";
        return difficultyOrder[difficulty] || 4;
    }, "asc"); // æŒ‰éš¾åº¦æ’åº

if (unfinishedQuestions.length > 0) {
    dv.header(1, "ğŸ“ æœªå®Œæˆé¢˜ç›®");
    dv.table(
        ["é¢˜ç›®é“¾æ¥", "éš¾åº¦", "å…³è”çŸ¥è¯†ç‚¹"],
        unfinishedQuestions.map(p => [
            p.file.link,
            p.file.tags.find(t => t.startsWith(DEFFICULTY_PREFIX))?.split("/").pop() || "æœªæ ‡æ³¨",
            p.file.tags
                .filter(t => t.startsWith(KNOWLEDGE_PREFIX))
                .map(t => t.split('/')[2])
                .join(', ') || "--"
        ])
    );
}

// ================
// æ£€æŸ¥æœªè¿›è¡Œæ¯”è¾ƒçš„è§£ç­”
// ================

// è·å–æ‰€æœ‰å¸¦æœ‰ #è§£ç­”/ æ ‡ç­¾çš„ä»£ç æ–‡ä»¶
const allSolutionFiles = dv.pages("#è§£ç­”/");

// æ‰¾å‡ºé‚£äº›æ²¡æœ‰å¯¹åº”æ¯”è¾ƒæ–‡ä»¶çš„è§£ç­”
const uncompairedSolutions = allSolutionFiles.filter(solutionFile => {
    // ä»æ–‡ä»¶åæå–é¢˜å·
    const fileNumberMatch = solutionFile.file.name.match(/^(\d+)\./);
    if (!fileNumberMatch) return false;
    const problemNumber = fileNumberMatch[1];
    
    // æ£€æŸ¥æ˜¯å¦æœ‰å¯¹åº”çš„æ¯”è¾ƒæ–‡ä»¶
    const hasComparisonFile = allComparisonFiles.some(compFile => {
        const compFileNumberMatch = compFile.file.name.match(/^(\d+)\./);
        return compFileNumberMatch && compFileNumberMatch[1] === problemNumber;
    });
    
    // å¦‚æœæ²¡æœ‰å¯¹åº”çš„æ¯”è¾ƒæ–‡ä»¶ï¼Œåˆ™è¿”å› trueï¼Œè¡¨ç¤ºè¿™ä¸ªè§£ç­”æœªè¿›è¡Œæ¯”è¾ƒ
    return !hasComparisonFile;
});

// å¦‚æœæœ‰æœªæ¯”è¾ƒçš„è§£ç­”æ–‡ä»¶ï¼Œåˆ™æ˜¾ç¤ºå®ƒä»¬
if (uncompairedSolutions.length > 0) {
    dv.header(1, "ğŸ“‹ æœªæ¯”è¾ƒçš„è§£ç­”");
    dv.table(
        ["é¢˜å·", "è§£ç­”æ–‡ä»¶", "åˆ›å»ºæ—¥æœŸ"],
        uncompairedSolutions.map(solution => {
            // æå–é¢˜å·
            const fileNumberMatch = solution.file.name.match(/^(\d+)\./);
            const problemNumber = fileNumberMatch ? fileNumberMatch[1] : "æœªçŸ¥";
            
            // è·å–æ–‡ä»¶ä¸­çš„æ—¥æœŸæ ‡ç­¾ï¼Œæˆ–ä½¿ç”¨æ–‡ä»¶åˆ›å»ºæ—¥æœŸ
            const dateTag = solution.file.tags.find(t => t.match(/^#\d{4}\/\d{2}\/\d{2}$/));
            let dateStr = "æœªçŸ¥";
            
            if (dateTag) {
                dateStr = dateTag.substring(1); // å»æ‰ # å‰ç¼€
            } else if (solution.file.cday) {
                // å¦‚æœæœ‰æ–‡ä»¶åˆ›å»ºæ—¥æœŸï¼Œåˆ™ä½¿ç”¨å®ƒ
                const cday = new Date(solution.file.cday);
                dateStr = formatDate(cday);
            }
            
            return [
                problemNumber,
                solution.file.link,
                dateStr
            ];
        })
    );
}

```