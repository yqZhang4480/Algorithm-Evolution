```dataviewjs
// ================
// è°ƒè¯•é€‰é¡¹ 
// ================
const DEBUG_MODE = false; // è®¾ç½®ä¸ºtrueå¯ç”¨è°ƒè¯•
const DEBUG_DATE = "2025-04-02"; // è°ƒè¯•ç”¨æ—¥æœŸ (YYYY-MM-DD)
const app = this.app; // è·å–å…¨å±€appå¯¹è±¡

// è·å–å½“å‰æ—¥æœŸï¼ˆå¯è¢«è°ƒè¯•æ¨¡å¼è¦†ç›–ï¼‰
function getCurrentDate() {
    if (DEBUG_MODE) {
        return new Date(DEBUG_DATE);
    }
    return new Date();
}

// ================
// é…ç½®é¡¹
// ================
const CATEGORY_TAGS = ["#A", "#B", "#C"] // ç‹¬ç«‹çš„ä¸‰çº§åˆ†ç±»æ ‡ç­¾
const KNOWLEDGE_PREFIX = "#é¢˜ç›®/çŸ¥è¯†ç‚¹/"
const DEFFICULTY_PREFIX = "#é¢˜ç›®/éš¾åº¦/"
// å®šä¹‰å„ç±»åˆ«çš„æ›´æ–°å‘¨æœŸ(å¤©)
const UPDATE_CYCLES = {
    "#A": 5,  // Aç±»é¢˜ç›®æ¯5å¤©æ›´æ–°ä¸€æ¬¡
    "#B": 3,  // Bç±»é¢˜ç›®æ¯3å¤©æ›´æ–°ä¸€æ¬¡
    "#C": 1,  // Cç±»é¢˜ç›®æ¯å¤©æ›´æ–°
    "hot100": 1 // Hot100æ¨èæ¯å¤©æ›´æ–°ä¸€æ¬¡
}

// ================
// æ•°æ®å¤„ç†æ¶æ„
// ================
const classifyByTag = (tag) => (p) => p.file.tags.includes(tag)

// ================
// ç»Ÿä¸€çš„éšæœºæ•°ç”Ÿæˆå™¨ï¼ˆå¸¦çŠ¶æ€ï¼‰
// ================
function createSeededRandom(seed) {
    // çº¿æ€§åŒä½™ç”Ÿæˆå™¨ (LCG) å‚æ•°
    const a = 1664525;
    const c = 1013904223;
    const m = Math.pow(2, 32);
    let state = seed;

    return function() {
        state = (a * state + c) % m;
        return state / m; // è¿”å› 0~1 ä¹‹é—´çš„æµ®ç‚¹æ•°
    };
}

// è·å–å½“å‰æ—¥æœŸå’Œæ—¶é—´ä¿¡æ¯
dv.paragraph(`***${getCurrentDate().toISOString().slice(0, 10)}***`)

// ================
// é€šç”¨å‘¨æœŸéšæœºç”Ÿæˆå™¨å·¥å‚ï¼ˆä¿®å¤ç‰ˆï¼‰
// ================
function createPeriodicRandomGenerator(periodDays) {
    return function() {
        const currentDate = getCurrentDate();
        
        // è®¡ç®—æ—¥æœŸçš„å¤©æ•°ï¼ˆä»æŸä¸ªå›ºå®šæ—¥æœŸå¼€å§‹ï¼‰
        const daysSince1970 = Math.floor(currentDate.getTime() / (24 * 60 * 60 * 1000));
        const cycleNumber = Math.floor(daysSince1970 / periodDays);
        
        // è®¡ç®—å½“å‰å‘¨æœŸçš„èµ·å§‹æ—¥æœŸ
        const cycleDaysSince1970 = cycleNumber * periodDays - 1;
        const cycleStartDate = new Date(cycleDaysSince1970 * 24 * 60 * 60 * 1000);
        
        // è®¡ç®—å½“å‰å‘¨æœŸçš„ç»“æŸæ—¥æœŸ
        const nextCycleStartMs = ((cycleNumber + 1) * periodDays - 1) * 24 * 60 * 60 * 1000;
        const cycleEndDate = new Date(nextCycleStartMs);
        
        if (DEBUG_MODE) {
            console.log(`å‘¨æœŸ=${periodDays}å¤©, å½“å‰æ—¥æœŸ=${currentDate.toISOString().slice(0,10)}, å¤©æ•°=${daysSince1970}, å‘¨æœŸç¼–å·=${cycleNumber}`);
            console.log(`å‘¨æœŸèµ·å§‹=${cycleStartDate.toISOString().slice(0,10)}, å‘¨æœŸç»“æŸ=${cycleEndDate.toISOString().slice(0,10)}`);
        }
        
        return {
            random: createSeededRandom(cycleNumber),
            cycleNumber: cycleNumber,
            startDate: cycleStartDate,
            expiryDate: cycleEndDate,
            isExpired: currentDate >= cycleEndDate
        };
    }
}

// æ—¥æœŸæ ¼å¼åŒ–å‡½æ•°
function formatDate(date) {
    const options = { year: 'numeric', month: '2-digit', day: '2-digit' };
    return date.toLocaleDateString('zh-CN', options);
}

// ================
// åˆ›å»ºå„ç§å‘¨æœŸçš„éšæœºç”Ÿæˆå™¨
// ================
const categoryGenerators = {};
const categoryExpiryDates = {};
const categoryStartDates = {};
const categoryIsExpired = {};
for (const tag of CATEGORY_TAGS) {
    const cycle = UPDATE_CYCLES[tag];
    const { random, expiryDate, startDate, cycleNumber, isExpired } = createPeriodicRandomGenerator(cycle)();
    categoryGenerators[tag] = random;
    categoryExpiryDates[tag] = expiryDate;
    categoryStartDates[tag] = startDate;
    categoryIsExpired[tag] = isExpired;
    
    if (DEBUG_MODE) {
        console.log(`ç±»åˆ« ${tag} å‘¨æœŸç¼–å·: ${cycleNumber}, èµ·å§‹æ—¥æœŸ: ${startDate.toISOString().slice(0,10)}, æˆªæ­¢æ—¥æœŸ: ${expiryDate.toISOString().slice(0,10)}, æ˜¯å¦åˆ°æœŸ: ${isExpired}`);
    }
}

// åæ—¥å‘¨æœŸéšæœºç”Ÿæˆå™¨
const tenDayGenerator = createPeriodicRandomGenerator(10)();
const tenDayRandom = tenDayGenerator.random;
const tenDayStartDate = tenDayGenerator.startDate;
const tenDayExpiryDate = tenDayGenerator.expiryDate;
const tenDayIsExpired = tenDayGenerator.isExpired;

// Hot100å‘¨æœŸéšæœºç”Ÿæˆå™¨
const hot100Cycle = UPDATE_CYCLES["hot100"];
const hot100Generator = createPeriodicRandomGenerator(hot100Cycle)();
const hot100Random = hot100Generator.random;
const hot100StartDate = hot100Generator.startDate;
const hot100ExpiryDate = hot100Generator.expiryDate;
const hot100IsExpired = hot100Generator.isExpired;

if (DEBUG_MODE) {
    console.log(`åæ—¥ä¸“é¡¹å‘¨æœŸç¼–å·: ${tenDayGenerator.cycleNumber}, èµ·å§‹æ—¥æœŸ: ${tenDayStartDate.toISOString().slice(0,10)}, æˆªæ­¢æ—¥æœŸ: ${tenDayExpiryDate.toISOString().slice(0,10)}, æ˜¯å¦åˆ°æœŸ: ${tenDayIsExpired}`);
    console.log(`Hot100æ¨èå‘¨æœŸç¼–å·: ${hot100Generator.cycleNumber}, èµ·å§‹æ—¥æœŸ: ${hot100StartDate.toISOString().slice(0,10)}, æˆªæ­¢æ—¥æœŸ: ${hot100ExpiryDate.toISOString().slice(0,10)}, æ˜¯å¦åˆ°æœŸ: ${hot100IsExpired}`);
}

// è·å–æ‰€æœ‰æ¯”è¾ƒæ–‡ä»¶
const allComparisonFiles = dv.pages("#æ¯”è¾ƒ/");

// ================
// é€šç”¨çš„æ£€æŸ¥é¢˜ç›®åœ¨æŒ‡å®šå‘¨æœŸå†…æ˜¯å¦å·²å®Œæˆ
// ================
const isCompletedInPeriod = (problemNumber, requiredKnowledgeTag, startDate, endDate) => {
    // æŸ¥æ‰¾å¸¦æœ‰æ¯”è¾ƒæ ‡ç­¾çš„å¯¹åº”é¢˜å·æ–‡ä»¶
    const matchingFiles = allComparisonFiles.where(p => {
        // ä»æ–‡ä»¶åæå–é¢˜å·
        const fileNumberMatch = p.file.name.match(/^(\d+)\./);
        return fileNumberMatch && parseInt(fileNumberMatch[1]) === parseInt(problemNumber);
    });
    
    // è°ƒæ•´èµ·å§‹æ—¥æœŸæå‰ä¸€å¤©
    const adjustedStartDate = new Date(startDate);
    adjustedStartDate.setDate(adjustedStartDate.getDate() - 1);
    
    // æ£€æŸ¥ä»»ä½•åŒ¹é…çš„æ–‡ä»¶æ˜¯å¦åœ¨æŒ‡å®šå‘¨æœŸå†…ä¸”åŒ…å«ç›¸å…³çŸ¥è¯†ç‚¹æ ‡ç­¾
    return matchingFiles.some(p => {
        // è·å–æ–‡ä»¶ä¸­çš„æ—¥æœŸæ ‡ç­¾
        const dateTag = p.file.tags.find(t => t.match(/^#\d{4}\/\d{2}\/\d{2}$/));
        if (!dateTag) return false;
        
        // æ£€æŸ¥æ˜¯å¦åŒ…å«ç›¸åº”çŸ¥è¯†ç‚¹æ ‡ç­¾ï¼ˆå¦‚æœæä¾›äº†ï¼‰
        if (requiredKnowledgeTag && !p.file.tags.includes(requiredKnowledgeTag)) return false;
        
        // è§£ææ—¥æœŸæ ‡ç­¾
        const [year, month, day] = dateTag.substring(1).split('/').map(Number);
        const fileDate = new Date(year, month - 1, day);
        
        // ä½¿ç”¨è°ƒæ•´åçš„èµ·å§‹æ—¥æœŸæ£€æŸ¥
        return fileDate >= adjustedStartDate && fileDate <= endDate;
    });
};

// ================
// æ ¸å¿ƒé€»è¾‘å®ç°
// ================
const questionBank = dv.pages("#é¢˜ç›®/") 

// æ„å»ºæ™ºèƒ½æ•°æ®æº
const categorizedData = CATEGORY_TAGS.map(tag => ({
    icon: {
        "#A": "ğŸŸ¢", 
        "#B": "ğŸŸ¡", 
        "#C": "ğŸ”´"
    }[tag],
    name: `${tag[1]}`,
    cycle: UPDATE_CYCLES[tag],
    startDate: categoryStartDates[tag],
    expiryDate: categoryExpiryDates[tag],
    isExpired: categoryIsExpired[tag],
    items: questionBank.where(classifyByTag(tag))
}))

// è·å–å¹¶å­˜å‚¨éšæœºé€‰æ‹©çš„é—®é¢˜
// ä½¿ç”¨æ–‡ä»¶ç³»ç»ŸAPIä»ç¼“å­˜ä¸­è¯»å–æˆ–å‘ç¼“å­˜ä¸­å†™å…¥å½“å‰å‘¨æœŸé¢˜ç›®
function getOrCreatePeriodQuestion(tag, items, cycleNumber) {
    // æ„é€ ç¼“å­˜é”®å
    const cacheKey = `${tag.replace("#", "")}_cycle_${cycleNumber}`;
    
    try {
        // å°è¯•ä»ç¼“å­˜ä¸­è¯»å–
        let cachedQuestion = app.metadataCache.getCache(cacheKey);
        
        // å¦‚æœæ‰¾ä¸åˆ°ç¼“å­˜çš„é—®é¢˜æˆ–å·²è¿‡æœŸï¼Œé‡æ–°éšæœºé€‰æ‹©å¹¶ç¼“å­˜
        if (!cachedQuestion || categoryIsExpired[tag]) {
            const randomGenerator = categoryGenerators[tag];
            const index = Math.floor(randomGenerator() * items.length);
            cachedQuestion = items[index];
            
            // å°†æ–°é€‰æ‹©çš„é—®é¢˜å†™å…¥ç¼“å­˜
            app.metadataCache.setCache(cacheKey, cachedQuestion);
        }
        
        return cachedQuestion;
    } catch (error) {
        console.error(`æ— æ³•è®¿é—®æˆ–å†™å…¥ç¼“å­˜: ${error}`);
        // å‘ç”Ÿé”™è¯¯æ—¶å›é€€åˆ°ç›´æ¥éšæœºé€‰æ‹©
        const randomGenerator = categoryGenerators[tag];
        const index = Math.floor(randomGenerator() * items.length);
        return items[index];
    }
}

// ä»æ¯ä¸ªç±»åˆ«ä¸­éšæœºè·å–é¢˜ç›®ï¼ˆè€ƒè™‘å‘¨æœŸï¼‰
function pickRandomByCategory(items, tag) {
    if (items.length === 0) return null;
    
    // è·å–å½“å‰å‘¨æœŸç¼–å·
    const currentDate = getCurrentDate();
    const daysSince1970 = Math.floor(currentDate.getTime() / (24 * 60 * 60 * 1000));
    const cycle = UPDATE_CYCLES[tag];
    const cycleNumber = Math.floor(daysSince1970 / cycle);
    
    // ä½¿ç”¨ç¼“å­˜ç³»ç»Ÿè·å–æˆ–åˆ›å»ºé—®é¢˜
    return getOrCreatePeriodQuestion(tag, items, cycleNumber);
}

// é€šç”¨éšæœºé€‰æ‹©å‡½æ•°ï¼ˆä½¿ç”¨Fisher-Yatesæ´—ç‰Œç®—æ³•ï¼‰
function pickRandom(items, count, randomFn) {
    if (items.length === 0) return [];
    if (!count) count = 1;
    
    // åˆ›å»ºå‰¯æœ¬é¿å…ä¿®æ”¹åŸæ•°ç»„
    const shuffled = [...items];
    
    // Fisher-Yatesæ´—ç‰Œ
    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(randomFn() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    
    if (DEBUG_MODE) {
        console.log(`æ´—ç‰Œç»“æœ: ${JSON.stringify(shuffled.slice(0, 5))}...`);
    }
    
    return shuffled.slice(0, count);
}

// åŠ¨æ€ç”ŸæˆçŸ¥è¯†ç‚¹æ± 
const knowledgePool = [...new Set(
    questionBank.flatMap(p =>
        p.file.tags
            .filter(t => t.startsWith(KNOWLEDGE_PREFIX))
            .map(t => t.split('/')[2])
    )
)]

// ================
// åæ—¥ä¸“é¡¹é¢˜ç›®æŒä¹…åŒ–å­˜å‚¨
// ================
async function getOrCreateTenDaySpecialTopic(cycleNumber, knowledgePool) {
    if (DEBUG_MODE) {
        dv.paragraph("ğŸ” å¼€å§‹é€‰æ‹©ä¸“é¡¹ä¸»é¢˜...");
        dv.paragraph(`çŸ¥è¯†æ± å¤§å°: ${knowledgePool.length}`);
        dv.paragraph(`å½“å‰å‘¨æœŸ: ${cycleNumber}`);
    }

    try {
        // ç¡®ä¿appå¯¹è±¡å¯ç”¨
        if (!app || !app.vault) {
            const err = new Error("Obsidian Vault APIä¸å¯ç”¨");
            dv.paragraph(`âŒ ä¸¥é‡é”™è¯¯: ${err.message}`);
            throw err;
        }
        
        const {vault} = app;
        
        const storagePath = "algorithm-evolution/special-topic.json";
        
        // æ£€æŸ¥å¹¶åˆ›å»ºå­˜å‚¨ç›®å½•
        try {
            if (!await app.vault.adapter.exists("algorithm-evolution")) {
                await app.vault.createFolder("algorithm-evolution");
            }
        } catch (e) {
            console.error("åˆ›å»ºç›®å½•å¤±è´¥:", e);
            throw e;
        }

        // å°è¯•è¯»å–å­˜å‚¨æ–‡ä»¶
        let storedData = {};
        try {
            const fileContent = await app.vault.adapter.read(storagePath);
            storedData = JSON.parse(fileContent);
            if (DEBUG_MODE) {
                dv.paragraph(`âœ… æˆåŠŸè¯»å–å­˜å‚¨æ–‡ä»¶: ${storagePath}`);
                dv.paragraph(`ğŸ“ æ–‡ä»¶å†…å®¹: ${JSON.stringify(storedData)}`);
            }
        } catch (e) {
            if (e.message !== "File doesn't exist") {
                dv.paragraph(`âŒ è¯»å–å­˜å‚¨æ–‡ä»¶å¤±è´¥: ${e.message}`);
                console.error(e); // ä¿ç•™åŸå§‹é”™è¯¯æ—¥å¿—
            }
        }

        // æ£€æŸ¥æ˜¯å¦å·²æœ‰å½“å‰å‘¨æœŸçš„ä¸»é¢˜
        if (DEBUG_MODE) {
            dv.paragraph("ğŸ” æ£€æŸ¥å­˜å‚¨æ•°æ®...");
            dv.paragraph(`å­˜å‚¨æ•°æ®: ${JSON.stringify(storedData)}`);
            dv.paragraph(`å½“å‰å‘¨æœŸ: ${cycleNumber}`);
        }
        
        if (storedData.cycleNumber === cycleNumber &&
            storedData.topic &&
            knowledgePool.includes(storedData.topic)) {
            if (DEBUG_MODE) {
                dv.paragraph(`âœ… ä½¿ç”¨å·²æœ‰ä¸»é¢˜: ${storedData.topic}`);
            }
            return storedData.topic;
        } else if (DEBUG_MODE) {
            dv.paragraph("â„¹ï¸ éœ€è¦åˆ›å»ºæ–°ä¸»é¢˜");
        }

        // éšæœºé€‰æ‹©æ–°ä¸»é¢˜
        const randomTopic = pickRandom(knowledgePool, 1, tenDayRandom)[0];
        
        // ä¿å­˜å¹¶éªŒè¯æ–°ä¸»é¢˜
        const topicData = {
            cycleNumber: cycleNumber,
            topic: randomTopic,
            lastUpdated: new Date().toISOString()
        };
        
        try {
            await app.vault.adapter.write(
                storagePath,
                JSON.stringify(topicData, null, 2)
            );
            
            // éªŒè¯æ–‡ä»¶æ˜¯å¦åˆ›å»ºæˆåŠŸ
            if (!await app.vault.adapter.exists(storagePath)) {
                throw new Error("æ–‡ä»¶åˆ›å»ºå¤±è´¥ï¼Œä½†æœªæŠ¥é”™");
            }
            
            if (DEBUG_MODE) {
                const savedContent = await app.vault.adapter.read(storagePath);
                dv.paragraph(`âœ… æ–‡ä»¶ä¿å­˜æˆåŠŸ: ${storagePath}`);
                dv.paragraph(`ğŸ“ æ–‡ä»¶å†…å®¹: ${savedContent}`);
            }
        } catch (e) {
            dv.paragraph(`âŒ æ–‡ä»¶ä¿å­˜å¤±è´¥: ${e.message}`);
            console.error("æ–‡ä»¶ä¿å­˜é”™è¯¯è¯¦æƒ…:", e);
            throw e;
        }

        if (DEBUG_MODE) {
            dv.paragraph(`æ–°é€‰æ‹©çš„ä¸“é¡¹ä¸»é¢˜: ${randomTopic} å¹¶å­˜å‚¨`);
            dv.paragraph(`çŸ¥è¯†ç‚¹æ± å¤§å°: ${knowledgePool.length}`);
            dv.paragraph(`BFSå‡ºç°æ¬¡æ•°: ${knowledgePool.filter(x => x === "å¹¿åº¦ä¼˜å…ˆæœç´¢").length}`);
        }
        
        return randomTopic;
    } catch (e) {
        dv.paragraph(`å­˜å‚¨æ“ä½œå¤±è´¥:${e}`);
        return pickRandom(knowledgePool, 1, tenDayRandom)[0];
    }
}

// ================
// é‡æ¸©åŠŸèƒ½æŒä¹…åŒ–å­˜å‚¨
// ================
async function getOrCreateReviewData(cycleNumber) {
    try {
        const storagePath = "algorithm-evolution/review.json";
        
        // å°è¯•è¯»å–å­˜å‚¨æ–‡ä»¶
        let storedData = { selectedFiles: [] };
        try {
            const fileContent = await app.vault.adapter.read(storagePath);
            storedData = JSON.parse(fileContent);
            // ç¡®ä¿æœ‰selectedFileså­—æ®µ
            if (!storedData.selectedFiles) {
                storedData.selectedFiles = [];
            }
            if (DEBUG_MODE) {
                dv.paragraph(`âœ… æˆåŠŸè¯»å–é‡æ¸©å­˜å‚¨æ–‡ä»¶: ${storagePath}`);
                dv.paragraph(`é€‰ä¸­æ–‡ä»¶: ${storedData.selectedFiles.join(', ')}`);
            }
        } catch (e) {
            if (e.message !== "File doesn't exist") {
                dv.paragraph(`âŒ è¯»å–é‡æ¸©å­˜å‚¨æ–‡ä»¶å¤±è´¥: ${e.message}`);
            }
        }

        // æ£€æŸ¥æ˜¯å¦å·²æœ‰å½“å‰å‘¨æœŸçš„æ•°æ®
        if (storedData.cycleNumber === cycleNumber) {
            if (DEBUG_MODE) {
                dv.paragraph(`âœ… ä½¿ç”¨å·²æœ‰é‡æ¸©æ•°æ®`);
            }
            return storedData;
        }

        // åˆ›å»ºæ–°æ•°æ®
        // è·å–å„ç±»åˆ«é€‰ä¸­çš„é¢˜ç›®
        const selectedQuestions = categorizedData
            .map(cat => pickRandomByCategory(cat.items, `#${cat.name}`))
            .filter(Boolean)
            .map(q => q.file.name);
        
        const reviewData = {
            cycleNumber: cycleNumber,
            lastUpdated: new Date().toISOString(),
            selectedFiles: selectedQuestions
        };
        
        try {
            await app.vault.adapter.write(
                storagePath,
                JSON.stringify(reviewData, null, 2)
            );
            
            if (DEBUG_MODE) {
                dv.paragraph(`âœ… é‡æ¸©æ•°æ®ä¿å­˜æˆåŠŸ: ${storagePath}`);
            }
        } catch (e) {
            dv.paragraph(`âŒ é‡æ¸©æ•°æ®ä¿å­˜å¤±è´¥: ${e.message}`);
            throw e;
        }
        
        return reviewData;
    } catch (e) {
        dv.paragraph(`é‡æ¸©å­˜å‚¨æ“ä½œå¤±è´¥:${e}`);
        return { cycleNumber: cycleNumber, lastUpdated: new Date().toISOString() };
    }
}

// ================
// Hot100æ¨èæŒä¹…åŒ–å­˜å‚¨
// ================
async function getOrCreateHot100Data(cycleNumber) {
    try {
        const storagePath = "algorithm-evolution/hot100.json";
        
        // å°è¯•è¯»å–å­˜å‚¨æ–‡ä»¶
        let storedData = { selectedFiles: [] };
        try {
            const fileContent = await app.vault.adapter.read(storagePath);
            storedData = JSON.parse(fileContent);
            // ç¡®ä¿æœ‰selectedFileså­—æ®µ
            if (!storedData.selectedFiles) {
                storedData.selectedFiles = [];
            }
            if (DEBUG_MODE) {
                dv.paragraph(`âœ… æˆåŠŸè¯»å–Hot100å­˜å‚¨æ–‡ä»¶: ${storagePath}`);
                dv.paragraph(`é€‰ä¸­æ–‡ä»¶: ${storedData.selectedFiles.join(', ')}`);
            }
        } catch (e) {
            if (e.message !== "File doesn't exist") {
                dv.paragraph(`âŒ è¯»å–Hot100å­˜å‚¨æ–‡ä»¶å¤±è´¥: ${e.message}`);
            }
        }

        // æ£€æŸ¥æ˜¯å¦å·²æœ‰å½“å‰å‘¨æœŸçš„æ•°æ®
        if (storedData.cycleNumber === cycleNumber) {
            if (DEBUG_MODE) {
                dv.paragraph(`âœ… ä½¿ç”¨å·²æœ‰Hot100æ•°æ®`);
            }
            return storedData;
        }

        // åˆ›å»ºæ–°æ•°æ®
        // è·å–é€‰ä¸­çš„Hot100é¢˜ç›®
        const selectedHot100 = pickRandom(dv.pages("#hot100"), 3, hot100Random)
            .map(p => p.file.name);
            
        const hot100Data = {
            cycleNumber: cycleNumber,
            lastUpdated: new Date().toISOString(),
            selectedFiles: selectedHot100
        };
        
        try {
            await app.vault.adapter.write(
                storagePath,
                JSON.stringify(hot100Data, null, 2)
            );
            
            if (DEBUG_MODE) {
                dv.paragraph(`âœ… Hot100æ•°æ®ä¿å­˜æˆåŠŸ: ${storagePath}`);
            }
        } catch (e) {
            dv.paragraph(`âŒ Hot100æ•°æ®ä¿å­˜å¤±è´¥: ${e.message}`);
            throw e;
        }
        
        return hot100Data;
    } catch (e) {
        dv.paragraph(`Hot100å­˜å‚¨æ“ä½œå¤±è´¥:${e}`);
        return { cycleNumber: cycleNumber, lastUpdated: new Date().toISOString() };
    }
}

// é€‰æ‹©ä»Šæ—¥ä¸“é¡¹ä¸»é¢˜ - ä½¿ç”¨æŒä¹…åŒ–ç‰ˆæœ¬
if (DEBUG_MODE) {
    dv.paragraph(`### è°ƒè¯•ä¿¡æ¯
    - çŸ¥è¯†ç‚¹æ± : ${JSON.stringify(knowledgePool)}
    - å½“å‰å‘¨æœŸ: ${tenDayGenerator.cycleNumber}
    - éšæœºç§å­: ${tenDayRandom()}
    `);
}

let todayHotTopic = "æ‰€æœ‰é¢†åŸŸ";
try {
    todayHotTopic = knowledgePool.length > 0
        ? await getOrCreateTenDaySpecialTopic(tenDayGenerator.cycleNumber, knowledgePool)
        : "æ‰€æœ‰é¢†åŸŸ";

if (DEBUG_MODE) {
    dv.paragraph(`é€‰ä¸­çš„ä¸“é¡¹ä¸»é¢˜: **${todayHotTopic}**
    å­˜å‚¨è·¯å¾„: .algorithm-evolution/special-topic.json`);
}
} catch (e) {}

// åˆå§‹åŒ–é‡æ¸©æ•°æ®
try {
    await getOrCreateReviewData(tenDayGenerator.cycleNumber);
} catch (e) {
    console.error("åˆå§‹åŒ–é‡æ¸©æ•°æ®å¤±è´¥:", e);
}

// åˆå§‹åŒ–Hot100æ•°æ®
try {
    await getOrCreateHot100Data(hot100Generator.cycleNumber);
} catch (e) {
    console.error("åˆå§‹åŒ–Hot100æ•°æ®å¤±è´¥:", e);
}

// ================
// æå–å¸¦ #æ¯”è¾ƒ/ æ ‡ç­¾ä¸” #YYYY/MM/DD æ ‡ç­¾åœ¨æœ¬æœˆçš„æ–‡ä»¶
// ================
const currentYear = getCurrentDate().getFullYear();
const currentMonth = getCurrentDate().getMonth() + 1; // æœˆä»½ä» 0 å¼€å§‹ï¼Œéœ€è¦åŠ  1

const comparisonFiles = dv.pages("#æ¯”è¾ƒ/")
    .where(p => {
        const dateTag = p.file.tags.find(t => t.startsWith("#" + currentYear + "/"));
        if (!dateTag) return false;
        const [year, month] = dateTag.split('/').slice(0, 2);
        return parseInt(month) === currentMonth;
    });

// ================
// å±•ç¤ºç»“æœ
// ================
dv.header(1, "ğŸ“Š æœ¬æœˆè¿›åº¦");
dv.paragraph(`\`\`\`progressbar\nid: progress-0\nkind: manual\nname: "è¿›åº¦({value}/{max})"\nvalue: ${comparisonFiles.length}\nmax: 100\nwidth: 60%\nbutton: false\n\`\`\``);


// ================
// å¯è§†åŒ–æ¨¡å—
// ================
dv.header(1, `âŒ› é‡æ¸©`)
// è·å–é‡æ¸©æ•°æ®ä¸­çš„é€‰ä¸­æ–‡ä»¶
const reviewData = await getOrCreateReviewData(tenDayGenerator.cycleNumber);

dv.table(
    ["åˆ†ç±»", "éšæœºæŠ½é¢˜", "éš¾åº¦", "æˆªæ­¢æ—¥æœŸ", "å®Œæˆ"],
    categorizedData.map((section, index) => {
        // ä¼˜å…ˆä½¿ç”¨æŒä¹…åŒ–çš„é€‰ä¸­æ–‡ä»¶
        let caseFile = null;
        let problemName = reviewData.selectedFiles[index];
        
        if (problemName) {
            caseFile = questionBank.find(p => p.file.name === problemName);
        }
        
        // å¦‚æœæ²¡æœ‰é€‰ä¸­æ–‡ä»¶ï¼Œåˆ™éšæœºé€‰æ‹©
        if (!caseFile) {
            caseFile = pickRandomByCategory(section.items, `#${section.name}`);
            problemName = caseFile?.file.name;
        }
        
        // æå–é¢˜å·å’Œæ£€æŸ¥å®Œæˆæƒ…å†µ
        let problemNumber = null;
        let isCompleted = false;
        
        if (caseFile) {
            const problemNumberMatch = caseFile.file.name.match(/^(\d+)\./);
            problemNumber = problemNumberMatch ? problemNumberMatch[1] : null;
            isCompleted = problemNumber && isCompletedInPeriod(
                problemNumber,
                null, // ä¸éœ€è¦ç‰¹å®šçŸ¥è¯†ç‚¹æ ‡ç­¾
                section.startDate,
                section.expiryDate
            );
        }
        
        return [
            `${section.icon} ${section.name} (${section.items.length})`,
            caseFile ? caseFile.file.link : "â é¢˜åº“ç©ºç¼º",
            caseFile ? caseFile.file.tags
                .filter(t => t.startsWith(DEFFICULTY_PREFIX))
                .map(t => t.split('/')[2]).join(', ') : "--",
            formatDate(section.expiryDate),
            isCompleted ? "âœ…" : "â¬œ"
        ]
    })
)

// ================
// Hot100 é¢˜ç›®æŒ‘é€‰
// ================
const hot100Questions = dv.pages("#hot100");
const randomHot100Questions = pickRandom(hot100Questions, 3, hot100Random);

// å±•ç¤ºç»“æœ
if (randomHot100Questions.length > 0) {
    dv.header(1, "ğŸ”¥ Hot 100 æ¨è");
    dv.paragraph(`æˆªæ­¢æ—¥æœŸ: ${formatDate(hot100ExpiryDate)}`);
    
    // è·å–Hot100æ•°æ®ä¸­çš„é€‰ä¸­æ–‡ä»¶
    const hot100Data = await getOrCreateHot100Data(hot100Generator.cycleNumber);
    
    dv.table(
        ["é¢˜ç›®", "éš¾åº¦", "å®Œæˆ"],
        randomHot100Questions.map((p, index) => {
            // ä¼˜å…ˆä½¿ç”¨æŒä¹…åŒ–çš„é€‰ä¸­æ–‡ä»¶
            let problem = p;
            if (hot100Data.selectedFiles[index]) {
                const selectedProblem = dv.pages("#hot100")
                    .find(q => q.file.name === hot100Data.selectedFiles[index]);
                if (selectedProblem) {
                    problem = selectedProblem;
                }
            }
            
            // æå–é¢˜å·
            const problemNumberMatch = problem.file.name.match(/^(\d+)\./);
            const problemNumber = problemNumberMatch ? problemNumberMatch[1] : null;
            
            // æ£€æŸ¥æ˜¯å¦å®Œæˆ
            const isCompleted = problemNumber && isCompletedInPeriod(
                problemNumber,
                null, // ä¸éœ€è¦ç‰¹å®šçŸ¥è¯†ç‚¹æ ‡ç­¾
                hot100StartDate,
                hot100ExpiryDate
            );
            
            return [
                problem.file.link,
                problem.file.tags.find(t => t.startsWith(DEFFICULTY_PREFIX))?.split("/").pop() || "æœªæ ‡æ³¨",
                isCompleted ? "âœ…" : "â¬œ"
            ];
        })
    );
} else {
    dv.paragraph("ğŸ“­ ä»Šæ—¥æ²¡æœ‰ Hot 100 é¢˜ç›®æ¨èã€‚");
}

// ================
// åæ—¥ä¸“é¡¹é¢˜ç›®å±•ç¤ºï¼ˆæ·»åŠ å®Œæˆåˆ—ï¼‰
// ================
dv.header(1, `ğŸŒŸ åæ—¥ä¸“é¡¹ï¼š${todayHotTopic}`)
dv.paragraph(`æˆªæ­¢æ—¥æœŸï¼š${formatDate(tenDayExpiryDate)}`)

const currentKnowledgeTag = KNOWLEDGE_PREFIX + todayHotTopic;
const difficultyOrder = { "ç®€å•": 1, "ä¸­ç­‰": 2, "å›°éš¾": 3, "æœªçŸ¥": 4 };

const specialQuestions = questionBank
    .where(p => p.file.tags.includes(currentKnowledgeTag))
    .sort(p => {
        const diffTag = p.file.tags.find(t => t.startsWith(DEFFICULTY_PREFIX));
        const difficulty = diffTag ? diffTag.split("/").pop() : "æœªçŸ¥";
        return difficultyOrder[difficulty] || 4;
    }, "asc");

if (specialQuestions.length > 0) {
    dv.table(
        ["é¢˜ç›®é“¾æ¥", "éš¾åº¦", "å®Œæˆ"],
        specialQuestions.map(p => {
            // ä»æ–‡ä»¶åæå–é¢˜å·
            const problemNumberMatch = p.file.name.match(/^(\d+)\./);
            const problemNumber = problemNumberMatch ? problemNumberMatch[1] : null;
            
            // æ£€æŸ¥æ˜¯å¦å®Œæˆ - ä½¿ç”¨ä¸“é—¨çš„è§„åˆ™ï¼Œè¦æ±‚æ¯”è¾ƒæ–‡ä»¶å¿…é¡»åŒ…å«çŸ¥è¯†ç‚¹æ ‡ç­¾
            const isCompleted = problemNumber && isCompletedInPeriod(
                problemNumber, 
                currentKnowledgeTag, // å¿…é¡»åŒ…å«å½“å‰ä¸“é¡¹çš„çŸ¥è¯†ç‚¹æ ‡ç­¾
                tenDayStartDate, 
                tenDayExpiryDate
            );
            
            return [
                p.file.link,
                p.file.tags.find(t => t.startsWith(DEFFICULTY_PREFIX))?.split("/").pop() || "æœªæ ‡æ³¨",
                isCompleted ? "âœ…" : "â¬œ"
            ];
        })
    );
}

// ================
// æœªå®Œæˆé¢˜ç›®å±•ç¤ºï¼ˆæ— ABCæ ‡ç­¾çš„é¢˜ç›®ï¼‰
// ================
const unfinishedQuestions = questionBank
    .where(p => !p.file.tags.some(t => CATEGORY_TAGS.includes(t))) // è¿‡æ»¤æ— ABCæ ‡ç­¾çš„é¢˜ç›®
    .sort(p => {
        const diffTag = p.file.tags.find(t => t.startsWith(DEFFICULTY_PREFIX));
        const difficulty = diffTag ? diffTag.split("/").pop() : "æœªçŸ¥";
        return difficultyOrder[difficulty] || 4;
    }, "asc"); // æŒ‰éš¾åº¦æ’åº

if (unfinishedQuestions.length > 0) {
    dv.header(1, "ğŸ“ æœªå®Œæˆé¢˜ç›®");
    dv.table(
        ["é¢˜ç›®é“¾æ¥", "éš¾åº¦", "å…³è”çŸ¥è¯†ç‚¹"],
        unfinishedQuestions.map(p => [
            p.file.link,
            p.file.tags.find(t => t.startsWith(DEFFICULTY_PREFIX))?.split("/").pop() || "æœªæ ‡æ³¨",
            p.file.tags
                .filter(t => t.startsWith(KNOWLEDGE_PREFIX))
                .map(t => t.split('/')[2])
                .join(', ') || "--"
        ])
    );
}

// ================
// æ£€æŸ¥æœªè¿›è¡Œæ¯”è¾ƒçš„è§£ç­”
// ================

// è·å–æ‰€æœ‰å¸¦æœ‰ #è§£ç­”/ æ ‡ç­¾çš„ä»£ç æ–‡ä»¶
const allSolutionFiles = dv.pages("#è§£ç­”/");

// æ‰¾å‡ºé‚£äº›æ²¡æœ‰å¯¹åº”æ¯”è¾ƒæ–‡ä»¶çš„è§£ç­”
const uncompairedSolutions = allSolutionFiles.filter(solutionFile => {
    // ä»æ–‡ä»¶åæå–é¢˜å·
    const fileNumberMatch = solutionFile.file.name.match(/^(\d+)\./);
    if (!fileNumberMatch) return false;
    const problemNumber = fileNumberMatch[1];
    
    // æ£€æŸ¥æ˜¯å¦æœ‰å¯¹åº”çš„æ¯”è¾ƒæ–‡ä»¶
    const hasComparisonFile = allComparisonFiles.some(compFile => {
        const compFileNumberMatch = compFile.file.name.match(/^(\d+)\./);
        return compFileNumberMatch && compFileNumberMatch[1] === problemNumber;
    });
    
    // å¦‚æœæ²¡æœ‰å¯¹åº”çš„æ¯”è¾ƒæ–‡ä»¶ï¼Œåˆ™è¿”å› trueï¼Œè¡¨ç¤ºè¿™ä¸ªè§£ç­”æœªè¿›è¡Œæ¯”è¾ƒ
    return !hasComparisonFile;
});

// å¦‚æœæœ‰æœªæ¯”è¾ƒçš„è§£ç­”æ–‡ä»¶ï¼Œåˆ™æ˜¾ç¤ºå®ƒä»¬
if (uncompairedSolutions.length > 0) {
    dv.header(1, "ğŸ“‹ æœªæ¯”è¾ƒçš„è§£ç­”");
    dv.table(
        ["é¢˜å·", "è§£ç­”æ–‡ä»¶", "åˆ›å»ºæ—¥æœŸ"],
        uncompairedSolutions.map(solution => {
            // æå–é¢˜å·
            const fileNumberMatch = solution.file.name.match(/^(\d+)\./);
            const problemNumber = fileNumberMatch ? fileNumberMatch[1] : "æœªçŸ¥";
            
            // è·å–æ–‡ä»¶ä¸­çš„æ—¥æœŸæ ‡ç­¾ï¼Œæˆ–ä½¿ç”¨æ–‡ä»¶åˆ›å»ºæ—¥æœŸ
            const dateTag = solution.file.tags.find(t => t.match(/^#\d{4}\/\d{2}\/\d{2}$/));
            let dateStr = "æœªçŸ¥";
            
            if (dateTag) {
                dateStr = dateTag.substring(1); // å»æ‰ # å‰ç¼€
            } else if (solution.file.cday) {
                // å¦‚æœæœ‰æ–‡ä»¶åˆ›å»ºæ—¥æœŸï¼Œåˆ™ä½¿ç”¨å®ƒ
                const cday = new Date(solution.file.cday);
                dateStr = formatDate(cday);
            }
            
            return [
                problemNumber,
                solution.file.link,
                dateStr
            ];
        })
    );
}
```