#解答/

```C++
// @lc app=leetcode.cn id=605 lang=cpp
// @lc code=start
class Solution {
public:
  bool allContained(string s, const string& t) {
    if (s.size() < t.size()) return false;
    for (auto it = t.cbegin(); it != t.cend(); it++) {
      auto index = s.find_first_of(*it);
      if (index == string::npos) { return false; }
      s.erase(index, 1);
    }
    return true;
  }
  string minWindow(string s, string t) {
    auto l = s.cbegin();
    auto r = s.cbegin(); // [l, r)
    size_t min_key = -1;
    std::pair<string::const_iterator, string::const_iterator> min_val = {l, r};
    // Find the first covering pair
    while (r != s.cend() && !allContained(string(l, r), t)) { ++r; }
    if (!allContained(string(l, r), t)) { return ""s; }
    while (l != r && allContained(string(l, r), t)) { ++l; }
    --l;
    min_key = r - l;
    min_val = {l, r};
    // Then drop some on getting one
    if (r == s.cend()) { return string(min_val.first, min_val.second); }
    while (r != s.cend()) {
      ++r;
      while (r != s.cend() && t.find_first_of(*r) == string::npos) { ++r; }
      while (l != r && t.find_first_of(*l) == string::npos) { ++l; }
      while (l != r && allContained(string(l, r), t)) {
        ++l;
      }
      --l;
      if (r - l < min_key) {
        min_key = r - l;
        min_val = {l, r};
      }
    }
    return string(min_val.first, min_val.second);
  }
};
// @lc code=end