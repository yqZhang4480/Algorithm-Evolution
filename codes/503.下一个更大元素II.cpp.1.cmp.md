#2025/02/04 #比较/

覆盖题目标签(2/2):  #题目/知识点/数组 #题目/知识点/单调栈
关联的播放列表：[[L11.101.10.11.练习1]]

# 比较目标

#比较/目标/思路

# 解答

![[503.下一个更大元素II.cpp.1.code]]

# 选中的参考答案

```cpp
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        int n = nums.size();
        vector<int> ret(n, -1);
        stack<int> stk;
        for (int i = 0; i < n * 2 - 1; i++) {
            while (!stk.empty() && nums[stk.top()] < nums[i % n]) {
                ret[stk.top()] = nums[i % n];
                stk.pop();
            }
            stk.push(i % n);
        }
        return ret;
    }
};
```

作者：力扣官方题解
链接：https://leetcode.cn/problems/next-greater-element-ii/solutions/637573/xia-yi-ge-geng-da-yuan-su-ii-by-leetcode-bwam/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# 评论

### 单调栈的原理

单调栈能够高效地处理 **Next Greater Element（下一个更大元素）** 或 **Next Smaller Element（下一个更小元素）** 的问题，其核心原理是 **“单调性 + 逐步消除无用信息”**。具体来说，它利用 **栈的先进先出特性**，保证栈中的元素始终保持单调性，从而在 **O(n) 时间复杂度** 内完成查询。

---

### 1. 单调栈为何能解决 Next Greater Element（NGE）问题？

##### 直观理解

对于每个元素 `nums[i]`，我们要找到 **下一个更大的元素**。如果使用 **暴力解法**，我们需要向后扫描整个数组，导致 **O(n²) 时间复杂度**。而单调栈可以避免重复扫描，因为 **一旦一个元素找到了下一个更大的元素，它就不再需要被考虑**。

##### 单调递减栈的核心思想

- **栈内始终保持单调递减（从栈底到栈顶的元素递减）**。
- **一旦新元素 `nums[i]` 比栈顶元素大**，说明栈顶元素的 **“下一个更大元素” 就是 `nums[i]`**，因此可以将栈顶元素出栈，并记录答案。
- 由于单调递减栈的特性，栈中只存放 **尚未找到更大元素的索引**，保证了 **O(n) 的时间复杂度**。

---

### 2. 详细分析单调栈的工作流程

##### 示例

假设输入数组为：

`nums = [2, 1, 2, 4, 3]`

**目标**：找到每个元素的下一个更大元素（Next Greater Element）。

##### 暴力解法（O(n²))

对于 `nums[i]`，遍历 `nums[i+1:]`，寻找第一个比 `nums[i]` 大的元素：

```
`nums[0] = 2`, 下一个更大元素是 4
`nums[1] = 1`, 下一个更大元素是 2
`nums[2] = 2`, 下一个更大元素是 4 
`nums[3] = 4`, 没有更大元素，返回 -1
`nums[4] = 3`, 没有更大元素，返回 -1
```

最终答案：

`[4, 2, 4, -1, -1]`

##### 单调栈解法（O(n))

使用 **单调递减栈** 维护索引：

###### 遍历步骤

- **遍历 `nums`，使用单调递减栈维护索引**：
- **遇到比栈顶元素更大的值**：
    - 说明 **栈顶元素的下一个更大元素已经找到**，弹出栈顶，并更新 `ret` 数组。

|步骤|当前元素|栈内容 (存索引)|操作|`ret`|
|---|---|---|---|---|
|**1**|2|`[0]`|入栈|`[-1, -1, -1, -1, -1]`|
|**2**|1|`[0,1]`|入栈|`[-1, -1, -1, -1, -1]`|
|**3**|2|`[0]` → `[0,2]`|`nums[1]=1` **找到更大元素**，更新 `ret[1]=2`，弹出 `1`|`[-1, 2, -1, -1, -1]`|
|**4**|4|`[]` → `[3]`|`nums[2]=2` **找到更大元素**，更新 `ret[2]=4`，弹出 `2`，`nums[0]=2` **找到更大元素**，更新 `ret[0]=4`，弹出 `0`|`[4, 2, 4, -1, -1]`|
|**5**|3|`[3, 4]`|入栈|`[4, 2, 4, -1, -1]`|

最终 `ret` 数组：

`[4, 2, 4, -1, -1]`

###### 时间复杂度分析

- 每个元素 **最多入栈一次，出栈一次**，即 **O(n)**。
- 相比暴力解法的 **O(n²)**，单调栈大幅优化了查询效率。

---

### 3. 单调栈的原理总结

1. **为什么能做到 O(n)？**
    
    - **每个元素最多入栈一次，出栈一次**，每个元素被处理两次（一次入栈、一次出栈），所以总操作次数是 **O(n)**。
    - 避免了暴力解法的重复扫描。
2. **为什么使用栈存索引而不是元素值？**
    
    - **索引可以用来查找元素的位置**，并且可以用于存储答案，而值可能会有重复，导致混淆。
3. **如何保证栈中的元素是递减的？**
    
    - **每次入栈前，弹出所有比当前元素小的栈顶元素**，确保 **栈顶始终是当前未找到更大元素的最小元素的索引**。

### 六、理解升华：何时该想到单调栈？

当问题满足以下特征时，可考虑单调栈：

1. **元素间的依赖关系具有方向性**（如后面的元素影响前面的元素）；
    
2. **需要快速剔除无效候选元素**（如一旦出现更大值，之前更小的值不再有意义）；
    
3. **多点问题**（一个元素可能可以决定多个元素的状态）。