#2024/05/27 #解答/ #解答/已解出/ #解答/评价/时间/ #解答/评价/空间/ 

``` cpp
class Solution {
	class iterator {
	private:
		ListNode* curr;
	public:
		iterator() = default;
		iterator(ListNode* c) : curr(c) {}
		auto& operator*() { return curr->val; }
		const auto& operator*() const { return curr->val; }
		ListNode* operator->() { return curr; }
		const ListNode* operator->() const { return curr; }
		bool operator==(const iterator& other) const { return curr == other.curr; };
		bool operator==(nullptr_t n) { return curr == n; } 
		iterator& operator++() { return (*this) += 1; }
		iterator operator++(int) { return exchange(curr, (*this) + 1); }
		iterator operator+(size_t i) const {
			auto p = curr;
			while (i--) { p = p->next; }
			return p;
		}
		iterator& operator+=(size_t i) { while (i--) { curr = curr->next; } return *this; }
		operator ListNode*() const { return curr; }
	};
public:
	pair<iterator, iterator> merge(iterator begin, iterator mid, iterator end) {
		auto prev1 = optional<iterator>(nullopt);
		auto p1 = begin, p2 = mid;
		while (p1 != mid && p2 != end) {
			if (*p1 <= *p2) { prev1 = p1++; }
			else {
				if (!prev1) {
					prev1 = begin = p2++;
					(*prev1)->next = p1;
				}
				else {
					(*prev1)->next = p2++;
					(++(*prev1))->next = p1;
				}
			}
		}
		if (p1 != mid) { p1->next = end; }
		return {begin, end};
	}
	ListNode* sortList(ListNode* head) {
		 size_t range_size = 1;
		 iterator it = head;
		 return merge(it, it + 3, it + 6);
	 }
};
```

结果