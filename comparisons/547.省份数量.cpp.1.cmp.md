#æ¯”è¾ƒ/ 

è¦†ç›–é¢˜ç›®æ ‡ç­¾ï¼ˆ2/4ï¼‰ï¼š #é¢˜ç›®/çŸ¥è¯†ç‚¹/å¹¶æŸ¥é›† #é¢˜ç›®/çŸ¥è¯†ç‚¹/å›¾
æ¯”è¾ƒç›®æ ‡ï¼š #æ¯”è¾ƒ/ç›®æ ‡/éšä¾¿çœ‹çœ‹ 

# è§£ç­”

![[../codes/547.çœä»½æ•°é‡.cpp.1.code|547.çœä»½æ•°é‡.cpp.1.code]]

# é€‰ä¸­çš„å‚è€ƒç­”æ¡ˆ

è‡ªå·±ä¼˜åŒ–çš„2ä¾‹

``` cpp
class Solution {
	size_t n;
	vector<size_t> uf;
	void merge(size_t from, size_t to) {
		uf[find(from)] = find(to);
	}
	size_t find(size_t index) {
		while (uf[index] != index) { index = uf[index]; }
		return index;
	}
public:
	int findCircleNum(vector<vector<int>>& isConnected) {
		n = isConnected.size();
		size_t start = 0;
		generate_n(back_inserter(uf), n, [&start]() { return start++; });
		for (size_t i = 0; i < n; ++i) {
			for (size_t j = i + 1; j < n; ++j) {
				if (isConnected[i][j]) { merge(i, j); }
			}
		}
		int cnt = 0;
        for (size_t i = 0; i < n; i++) {
            if (uf[i] == i) { ++cnt; }
        }
        return cnt;
	}
};
```

```cpp
class Solution {
	size_t n;
	void merge(vector<size_t>& uf, size_t from, size_t to) {
		uf[find(uf, from)] = find(uf, to);
	}
	size_t find(const vector<size_t>& uf, size_t index) {
		if (uf[index] == index) { return index; }
		return find(uf, uf[index]);
	}
public:
	int findCircleNum(vector<vector<int>>& isConnected) {
		n = isConnected.size();
		size_t start = 0;
		vector<size_t> uf;
		generate_n(back_inserter(uf), n, [&start]() { return start++; });
		for (size_t i = 0; i < n; ++i) {
			for (size_t j = i + 1; j < n; ++j) {
				if (isConnected[i][j]) { merge(uf, i, j); }
			}
		}
		return count_if(uf.cbegin(), uf.cend(), [&uf](const size_t& i){ return i == &i - &uf[0]; });
	}
};
```

# è¯„è®º

ç¬¬ä¸€ä¾‹å°† `count_if` æ¢ä¸ºè‡ªå·±å†™çš„forå¾ªç¯ï¼›ç¬¬äºŒä¾‹å°† `uf` ä»æˆå‘˜å˜é‡æ¢ä¸ºå±€éƒ¨å˜é‡ã€‚è¿™ä¸¤ä¾‹éƒ½èƒ½å¤§å¹…ä¼˜åŒ–æ—¶é—´æ€§èƒ½ã€‚

æœ‰è¶£çš„æ˜¯ï¼ŒVS Profiler æŒ‡å‡ºï¼Œé—®é¢˜å‡ºåœ¨è§£ç­”ä¸­ `count_if` ä¸Šã€‚çœ‹èµ·æ¥ï¼Œ `uf`  ä½œä¸ºå±€éƒ¨å˜é‡æ—¶ `i == &i - &uf[0]` çš„æ€§èƒ½ä¸è‡ªå·±å†™çš„forå¾ªç¯æ— å¼‚ï¼›è€Œä½œä¸ºæˆå‘˜å˜é‡æ—¶å…¶æ€§èƒ½æ¶ˆè€—å°±å¤§å¤§å¢åŠ ã€‚ 

æ›´æœ‰è¶£çš„æ˜¯ï¼Œç»åæ±‡ç¼–ï¼Œ `uf`  ä½œä¸ºå±€éƒ¨å˜é‡å’Œä½œä¸ºæˆå‘˜å˜é‡æ—¶ `count_if` å¯¹åº”çš„æ±‡ç¼–ä»£ç ä¼¼ä¹æ²¡æœ‰å®è´¨æ€§çš„å·®åˆ«ã€‚

æœ€æœ‰è¶£çš„æ˜¯ï¼Œåœ¨æˆ‘å†™ä¸‹ä»¥ä¸Šä¸¤æ®µè¯„è®ºåï¼Œæˆ‘å‘ç°æ‰€è°“çš„â€œå¤§å¹…ä¼˜åŒ–æ—¶é—´æ€§èƒ½â€å®é™…ä¸Šæ˜¯ Leetcode å¹³å°çš„æ€§èƒ½æ³¢åŠ¨ï¼Œåˆæäº¤äº†å‡ éï¼Œå‘ç°å…¶å®ç”¨æ—¶å·®ä¸å¤šï¼›è€Œä¹‹æ‰€ä»¥ Profiler æŒ‡å‡º  `count_if` å‡½æ•°è€—æ—¶æ›´å¤šï¼Œæ˜¯å› ä¸ºæˆ‘å†™çš„æµ‹è¯•ä»£ç æœ‰é—®é¢˜ğŸ˜…ï¼š

``` cpp
#include <vector>
#include <queue>
#include <iostream>
#include <algorithm>
#include <functional>
using namespace std;

::: Solution Code Here :::

int main()
{
    auto isConnected = vector<vector<int>>{ {1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, { 0,1,0,1,0,0,0,0,0,0,0,0,0,1,0 }, { 0,0,1,0,0,0,0,0,0,0,0,0,0,0,0 }, { 0,1,0,1,0,0,0,1,0,0,0,1,0,0,0 }, { 0,0,0,0,1,0,0,0,0,0,0,0,1,0,0 }, { 0,0,0,0,0,1,0,0,0,0,0,0,0,0,0 }, { 0,0,0,0,0,0,1,0,0,0,0,0,0,0,0 }, { 0,0,0,1,0,0,0,1,1,0,0,0,0,0,0 }, { 0,0,0,0,0,0,0,1,1,0,0,0,0,0,0 }, { 1,0,0,0,0,0,0,0,0,1,0,0,0,0,0 }, { 0,0,0,0,0,0,0,0,0,0,1,0,0,0,0 }, { 0,0,0,1,0,0,0,0,0,0,0,1,0,0,0 }, { 0,0,0,0,1,0,0,0,0,0,0,0,1,0,0 }, { 0,1,0,0,0,0,0,0,0,0,0,0,0,1,0 }, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 }};
    Solution s; /// !! uf is a member and is never cleared.
    size_t n = 20000;
    while (n--) s.findCircleNum(isConnected); 
    return 0;
}
```