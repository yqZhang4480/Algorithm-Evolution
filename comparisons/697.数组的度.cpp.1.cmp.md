#2025/02/05 #æ¯”è¾ƒ/

è¦†ç›–é¢˜ç›®æ ‡ç­¾(2/2):  #é¢˜ç›®/çŸ¥è¯†ç‚¹/æ•°ç»„ #é¢˜ç›®/çŸ¥è¯†ç‚¹/å“ˆå¸Œè¡¨
å…³è”çš„æ’­æ”¾åˆ—è¡¨ï¼š[[L11.101.10.11.ç»ƒä¹ 1]]

# æ¯”è¾ƒç›®æ ‡

#æ¯”è¾ƒ/ç›®æ ‡/æ—¶é—´ä¼˜åŒ– 

# è§£ç­”

![[697.æ•°ç»„çš„åº¦.cpp.1.code]]

# é€‰ä¸­çš„å‚è€ƒç­”æ¡ˆ

```cpp
class Solution {
public:
    struct Info {
        size_t count;  // å‡ºç°æ¬¡æ•°
        size_t first;  // é¦–æ¬¡å‡ºç°çš„ä½ç½®
        size_t last;   // æœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®
    };

    int findShortestSubArray(vector<int>& nums) {
        unordered_map<int, Info> mp;
        size_t n = nums.size();
        
        for (size_t i = 0; i < n; i++) {
            if (mp.contains(nums[i])) {
                mp[nums[i]].count++;
                mp[nums[i]].last = i;
            } else {
                mp[nums[i]] = {1, i, i};
            }
        }
        int maxNum = 0; size_t minLen = 0;
        for (auto& [_, info] : mp) {
            if (maxNum < info.count) {
                maxNum = info.count;
                minLen = info.last - info.first + 1;
            } else if (maxNum == info.count) {
                minLen = min(minLen, info.last - info.first + 1);
            }
        }
        
        return minLen;
    }
};
```

# è¯„è®º

ğŸ˜„!